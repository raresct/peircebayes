#!/usr/bin/env python2

from pkg_resources import resource_filename

from formula_gen import PBModel
from knowledge_compilation import compile_k
from prob_inference import PBInference

import numpy as np

import subprocess
import sys
import os
import shutil
import argparse
import json
import time

# logging stuff
import logging
from logging import debug as logd

def rewrite_dir(dir_path):
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)
    else:
        shutil.rmtree(dir_path)
        os.makedirs(dir_path)

def logical_inference(in_file, tmp_dir):
    in_file_name = os.path.basename(in_file)
    query_file_name = 'query.pl'
    aprob_file_name='aprob.pl'
    query_file = os.path.join(tmp_dir, query_file_name)
    aprob_out_name = 'aprob'
    aprob_out = os.path.join(tmp_dir, aprob_out_name)
    plate_out_name = 'plates'
    plate_out = os.path.join(aprob_out, plate_out_name)
    # installed
    aprob_file = resource_filename('peircebayes',aprob_file_name)
    # not installed
    #aprob_file = os.path.join('/home/rares/p/peircebayes/peircebayes/',
    #    aprob_file_name)
    copy_in_file_name = 'in_file.pl'
    copy_in_file = os.path.join(tmp_dir, copy_in_file_name)
    pl_log_file_name = 'aprob.log'
    pl_log_file = os.path.join(tmp_dir, pl_log_file_name)

    # create temporary dir and copy input to in_file.pl
    #rewrite_dir(tmp_dir) # this was moved to main function
    os.mkdir(aprob_out)
    os.mkdir(plate_out)
    shutil.copy(in_file, tmp_dir)
    shutil.move(os.path.join(tmp_dir, in_file_name), copy_in_file)

    # write query file
    write_query_file(query_file, aprob_file, copy_in_file)

    # call prolog
    with open(pl_log_file, 'w') as fout:
        #p1 = subprocess.Popen(['sicstus', '-l', query_file, '--noinfo'],
        #    stdout=fout, stderr=fout)
        # yap
        p1 = subprocess.Popen(['yap', '-l', query_file],
            stdout=fout, stderr=fout)
        p1.wait()


def write_query_file(query_file, aprob_file, copy_in_file):
    query_str = 'load_pb'
    with open(query_file, 'w') as fout:
        fout.write('''
% load the Aprob prolog file
:- ['{}'].
% load the input file and query
:- {}('{}').
% stop prolog
:- halt.
'''.format(aprob_file, query_str, copy_in_file))


def knowledge_compilation():
    option_args = {
        'probs_file'    : '/tmp/peircebayes/aprob/out.probs',
        'dir_file'      : '/tmp/peircebayes/aprob/plates'
    }
    model = PBModel(option_args)
    compile_k(model)
    #logd(model)
    return model

def probabilistic_inference(model, options):
    inf = PBInference(model)
    inf.gibbs_sampler_plates(**options)
    np.savez('/tmp/peircebayes/avg_samples', *inf.theta_avg)
    np.savez('/tmp/peircebayes/last_sample', *inf.theta)

def peircebayes():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("in_file",
        help="input pb file")
    parser.add_argument("-n", type=int,
        default = 100,
        help="number of sampling iterations")
    parser.add_argument("-b", "--burn", type=int,
        default = 0,
        help="number of burn-in iterations")
    parser.add_argument("-l", "--lag", type=int,
        default = 1,
        help="number of lag iterations")
    parser.add_argument("-s", "--seed", type=int,
        default = 1234,
        help="seed for numpy rng")
    parser.add_argument("-t", "--trackll", action="store_true",
        help="include likelihood information")
    parser.add_argument("-d","--debug", action="store_true",
        help="include some debug information")
    parser.add_argument("-c","--config", action="store_true",
        help="load arguments from json as in_file")
    cl_args = parser.parse_args()
    args = json.load(cl_args.in_file) if cl_args.config else cl_args
    tmp_dir = '/tmp/peircebayes' # TODO make this an option
    rewrite_dir(tmp_dir)
    if args.debug:
        logging.basicConfig(filename='/tmp/peircebayes/pb.log',
            level=logging.DEBUG)
    np.random.seed(args.seed)
    gibbs_options = {
        'n'         : args.n,
        'burn_in'   : args.burn,
        'lag'       : args.lag,
        'track_ll'  : args.trackll,
        'in_file'   : args.in_file
    }
    logd('### Started Logical Inference ###')
    t_li_start = time.time()
    logical_inference(args.in_file, tmp_dir)
    t_li_end = time.time()
    logd('Finished Logical Inference in:\n{} seconds'.format(t_li_end-t_li_start))
    logd('### Started Knowledge Compilation ###')
    t_kc_start = time.time()
    model = knowledge_compilation()
    t_kc_end = time.time()
    logd('Finished Knowledge Compilation in:\n{} seconds'.format(t_kc_end-t_kc_start))
    logd('### Started Probabilistic Inference ###')
    t_pi_start = time.time()
    probabilistic_inference(model, gibbs_options)
    t_pi_end = time.time()
    logd('Finished Probabilistic Inference in:\n{} seconds'.format(t_pi_end-t_pi_start))
    
def main():
    peircebayes()

if __name__=='__main__':
    main()
